#!/usr/bin/env python
# Copyright 2024 Sony Semiconductor Solutions Corp.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
"""
This script converts the SBOM file generated by cyclonedx-py into csv format.
"""
import csv
import pathlib
import re
from pathlib import Path

LICENSE_COLUMN_NAME = "license"
WHITELIST_PATH = pathlib.Path(__file__).parent.resolve() / "licenses_whitelist.txt"


def read_licenses_csv(filename: str) -> list[str]:
    values = []
    with open(filename, newline="", encoding="utf-8") as csvfile:
        reader = csv.DictReader(csvfile)

        if reader.fieldnames is None:
            raise ValueError(f"Failed to read headers from the {filename} CSV file.")

        if LICENSE_COLUMN_NAME not in reader.fieldnames:
            raise ValueError(
                f"Column {LICENSE_COLUMN_NAME} not found in the {filename} CSV file."
            )

        for row in reader:
            value = row[LICENSE_COLUMN_NAME]
            if value:
                values.append(value)

    return values


def simplify_version(version: str) -> str:
    # Remove any leading "v" if present
    version = version.lstrip("v")

    # Split the version string by dots
    parts = version.split(".")

    # Remove trailing zeros, but keep at least two components
    while len(parts) > 1 and parts[-1] == "0":
        parts.pop()

    # Rejoin the remaining parts to form the simplified version
    return ".".join(parts)


def get_license_token(value: str) -> list[str]:
    # Lowercase and replace '-' with space
    value = value.lower().replace("-", " ").strip("()")

    # Remove 'license', 'licence' and 'version' words, as they add useless clutter
    value = re.sub(r"\b(license|licence|version)\b", "", value)

    # Adhoc logic for particular cases
    if "bsd" in value:
        # The BSD license family has multiple license types, each of which is identified by various names,
        # as can be seen here: https://en.wikipedia.org/wiki/BSD_licenses
        # In here, we are handling 2 of such cases, which have been approved by the OSS Audit. In both cases,
        # we unify all possible names into a single token
        if "new" in value or "revised" in value or ("clause" in value and "3" in value):
            # This license version has the following variations:
            #   - 3-clause license
            #   - BSD License 2.0
            #   - Revised BSD License
            #   - New BSD License
            #   - Modified BSD License"
            value = "bsd 2.0"
        elif "simplified" in value or ("clause" in value and "2" in value):
            # This license version has the following variations:
            #   - 2-clause license
            #   - Simplified BSD License
            #   - FreeBSD License
            value = "freebsd"
    if "python" in value:
        # The Python 2.0 license is also known as "Python Software Foundation License Version 2"
        value = value.replace("software foundation", "")

    # Handle OR, -or-, / or similar connectors by splitting
    list_value: list[str] = re.split(r"[\s]*or[\s]*|[\s]*-or-[\s]*|[\s]*/[\s]*", value)

    if len(list_value) == 1:
        # Handling a special case with 2 Eclipse licenses in a single package
        positions = [
            m.start()
            for m in re.finditer(r"\b" + re.escape("eclipse") + r"\b", list_value[0])
        ]
        # We identify how many "Eclipse" words are there, and split the sentence into 2,
        # each containing one of the words and, thus, license
        if len(positions) > 1:
            second_occurrence = positions[1]
            part1 = list_value[0][:second_occurrence].strip()
            part2 = list_value[0][second_occurrence:].strip()
            list_value = [part1, part2]

    # Preprocess each split value separately
    processed_values = []
    for val in list_value:
        # Remove duplicate words
        words = val.split()
        unique_words = []
        for word in words:
            if word not in unique_words:
                unique_words.append(word)

        # We identify numerical element to move them to the back, for better generalization
        words_with_numbers = []
        for word in unique_words:
            if re.search(r"\d", word):
                words_with_numbers.append(word)

        non_numeric_words = [
            word for word in unique_words if word not in words_with_numbers
        ]

        # The final step involves reordering the license by moving the numbers to the back.
        # The rest of the license maintains the same order it had before
        final_value = " ".join(
            non_numeric_words + [simplify_version(word) for word in words_with_numbers]
        )

        # Add to processed values if not empty after processing
        if final_value.strip():
            processed_values.append(final_value.strip())

    # Return the list of processed values
    return processed_values


def read_licenses_file_list(filepath: Path) -> list[str]:
    with open(filepath) as f:
        return [x.strip() for x in f.readlines()]
